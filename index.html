<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>CastWeather ‚Ä¢ Farcaster MiniApp</title>
  <meta name="theme-color" content="#9d4df1" />
  <link rel="icon" href="https://raw.githubusercontent.com/CryptoExplor/weather-mini-app/main/icon.png" />
  <meta name="description" content="Get live weather, daily forecasts, adaptive greetings, and morning notifications right inside Farcaster." />
  
  <!-- Preconnect for Quick Auth performance -->
  <link rel="preconnect" href="https://auth.farcaster.xyz" />
  
  <!-- Farcaster Mini App Metadata -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://weather-base-app.vercel.app/image.png",
    "button":{
      "title":"CastWeather",
      "action":{
        "type":"launch_miniapp",
        "name":"CastWeather",
        "url":"https://weather-base-app.vercel.app/",
        "splashImageUrl":"https://weather-base-app.vercel.app/splash.png",
        "splashBackgroundColor":"#111111"
      }
    },
    "webhookUrl": "https://api.neynar.com/f/app/a701b63d-1e2b-4f40-916a-53d8c66dbddf/event"
  }' />
  
  <!-- Open Graph -->
  <meta property="og:title" content="Weather ‚Ä¢ Farcaster MiniApp" />
  <meta property="og:description" content="Get live weather, daily forecasts, and adaptive greetings right inside Farcaster." />
  <meta property="og:image" content="https://weather-base-app.vercel.app/image.png" />
  <meta property="og:url" content="https://weather-base-app.vercel.app/" />
  <meta name="twitter:card" content="summary_large_image" />

  <style>
    :root{
      --purple:#9d4df1;
      --glass-bg:rgba(255,255,255,0.08);
      --glass-bd:rgba(255,255,255,0.15);
      --text:#f6f6f7;
      --muted:#cfd2d9;
      --radius:12px;
      --maxw:350px;
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji;
      color:var(--text);
      background: radial-gradient(1200px 800px at 80% -10%, rgba(255,255,255,0.08), transparent 60%) fixed;
      transition: background 400ms ease;
      display:flex; align-items:center; justify-content:center; padding:16px;
    }
    .wrap{ width:100%; max-width:var(--maxw); }
    .card{ background:var(--glass-bg); border:1px solid var(--glass-bd); backdrop-filter: blur(14px); border-radius:var(--radius); padding:16px; box-shadow:0 10px 30px rgba(0,0,0,0.25); }
    .header{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px; }
    .title{ display:flex; align-items:center; gap:8px; font-weight:700; letter-spacing:.2px; }
    .badge{ padding:2px 8px; border-radius:999px; background:#201235; color:#caa9ff; border:1px solid #3b1a72; font-size:12px; }
    .user-badge{ padding:2px 8px; border-radius:999px; background:#1a2035; color:#a9c9ff; border:1px solid #1a3b72; font-size:11px; }
    .search{ display:flex; gap:8px; margin:10px 0 12px; }
    input[type="text"]{ flex:1; border-radius:10px; border:1px solid #303040; background:#12121a; color:var(--text); padding:10px 12px; outline:none; }
    input::placeholder{ color:#8b8fa3 }
    button{ border:none; background:var(--purple); color:white; border-radius:10px; padding:10px 12px; font-weight:600; cursor:pointer; transition: filter .2s ease, transform .02s; }
    button:hover{ filter: brightness(1.1); }
    button:active{ transform: translateY(1px) }
    button:disabled{ opacity:0.5; cursor:not-allowed; }
    .ghost{ background:transparent; border:1px solid #40355e; color:#d9c9ff; }
    .row{ display:flex; gap:12px; align-items:stretch; }
    .col{ flex:1 }
    .hero{ display:flex; gap:12px; align-items:center; margin:10px 0 14px; }
    .temp{ font-size:40px; font-weight:800; letter-spacing:-.5px; }
    .condition{ font-size:14px; color:var(--muted); }
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.05); font-size:13px; color:#dfe2ea; }
    .grid{ display:grid; grid-template-columns: repeat(2, 1fr); gap:8px; margin-top:10px; }
    .cell{ padding:10px; border-radius:10px; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.04); display:flex; align-items:center; justify-content:space-between; font-size:14px; }
    .foot{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-top:12px; }
    .hint{ color:#9aa1b7; font-size:12px }
    .small{ font-size:12px; color:#aab0c5 }
    .greeting{ margin:12px 0 0; padding:10px 12px; border-radius:10px; background:rgba(157,77,241,0.12); border:1px solid #3b1a72; color:#eadbff; font-size:14px; }
    .forecast{ display:flex; gap:8px; overflow-x:auto; padding:6px 2px 2px; margin-top:10px; -ms-overflow-style: none; scrollbar-width: none; }
    .forecast::-webkit-scrollbar{ display:none; }
    .fcard{ min-width:72px; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.04); border-radius:10px; padding:8px; text-align:center; font-size:12px; }
    .fday{ color:#cbd2e6; font-weight:600; }
    .ftemp{ font-weight:700; font-size:13px }
    .share-row{ display:flex; gap:8px; margin-top:12px; }
    .share-row button{ flex:1; }
    .bg-sunny{ background: linear-gradient(160deg, #FFB347 0%, #FF8C42 60%, #6b21a8 120%) fixed; }
    .bg-cloudy{ background: linear-gradient(160deg, #87CEEB 0%, #4682B4 60%, #312e81 120%) fixed; }
    .bg-rainy{ background: linear-gradient(160deg, #1e3a8a 0%, #1e40af 60%, #111827 120%) fixed; }
    .bg-night{ background: linear-gradient(160deg, #2e1065 0%, #581c87 60%, #111827 120%) fixed; }
    @media (prefers-reduced-motion: reduce){ *{ transition:none !important; animation:none !important; } }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      backdrop-filter: blur(4px);
    }
    .modal-content {
      background: var(--glass-bg);
      border: 1px solid var(--glass-bd);
      border-radius: var(--radius);
      margin: 20% auto;
      padding: 20px;
      width: 90%;
      max-width: 300px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .modal h3 { margin: 0 0 10px; color: var(--text); }
    .modal p { margin: 0 0 15px; color: var(--muted); font-size: 14px; }
    .modal button { margin: 0 5px; padding: 8px 16px; }
    .close { background: transparent; border: 1px solid var(--glass-bd); color: var(--text); }
  </style>
</head>
<body class="bg-night">
  <div class="wrap">
    <div class="card" role="region" aria-label="Weather app">
      <div class="header">
        <div class="title" aria-live="polite">
          <img src="https://raw.githubusercontent.com/CryptoExplor/weather-mini-app/main/icon.png" alt="CastWeather logo" style="width: 24px; height: 24px; border-radius: 4px;">
          <span>Weather</span>
          <span class="badge">Farcaster</span>
          <span class="user-badge" id="user-fid" style="display:none"></span>
        </div>
        <button id="btn-myloc" class="ghost" title="Back to my location" aria-label="Back to my location">üìç</button>
      </div>

      <div class="search" role="search">
        <input id="city" type="text" inputmode="search" placeholder="Search city (e.g., Bangalore)" aria-label="Search city" />
        <button id="btn-search" aria-label="Search weather">Search</button>
      </div>

      <div class="hero" aria-live="polite">
        <div style="font-size:38px" id="emoji">‚õÖ</div>
        <div>
          <div class="temp" id="temp">--¬∞C</div>
          <div class="condition" id="cond">Loading...</div>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <div class="chip" title="Humidity"><span>üíß</span><span id="humid">--%</span></div>
        </div>
        <div class="col">
          <div class="chip" title="Wind speed"><span>üçÉ</span><span id="wind">-- km/h</span></div>
        </div>
      </div>

      <div class="grid" aria-label="Details">
        <div class="cell"><span>Feels like</span><span id="feels">--¬∞C</span></div>
        <div class="cell"><span>Local time</span><span id="ltime">--:--</span></div>
      </div>

      <div class="forecast" id="forecast" aria-label="Forecast"></div>

      <div class="greeting" id="greeting" role="status">Fetching your greeting‚Ä¶</div>

      <!-- Share buttons -->
      <div class="share-row">
        <button id="btn-cast" title="Cast weather on Farcaster">üü£ CastWeather</button>
        <button id="btn-copy" class="ghost" title="Copy weather">üìã Copy</button>
      </div>

      <div class="share-row">
        <button id="btn-add-miniapp" class="ghost" title="Add to your mini apps">‚ûï Add MiniApp</button>
      </div>

      <div class="foot">
        <div class="hint" id="status">Detecting location‚Ä¶</div>
        <div class="small" id="refresh">Updated ‚Ä¢ ‚Äî</div>
      </div>
    </div>
  </div>

  <!-- Location Permission Modal -->
  <div id="locationModal" class="modal">
    <div class="modal-content">
      <h3 id="modal-title">üìç Enable Location Access</h3>
      <p id="modal-message">To get accurate weather for your area, please allow location access in your browser settings. This uses your device's GPS or nearby cell towers/WiFi for precision.</p>
      <button id="retryLocation" class="ghost">Retry Location</button>
      <button id="useIP" class="close">Use Approximate Location</button>
    </div>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';

    // Endpoints
    const OPEN_METEO = "https://api.open-meteo.com/v1/forecast";
    const GEO_CODE   = "https://geocoding-api.open-meteo.com/v1/search";
    const DEFAULT_CITY = { name:"Bangalore", latitude:12.9716, longitude:77.5946 };

    // WMO codes
    const WMO = {
      0:{t:"Clear sky",e:"‚òÄÔ∏è",bg:"sunny"}, 1:{t:"Mainly clear",e:"üå§Ô∏è",bg:"sunny"}, 2:{t:"Partly cloudy",e:"‚õÖ",bg:"cloudy"}, 3:{t:"Overcast",e:"‚òÅÔ∏è",bg:"cloudy"},
      45:{t:"Fog",e:"üå´Ô∏è",bg:"cloudy"}, 48:{t:"Depositing rime fog",e:"üå´Ô∏è",bg:"cloudy"},
      51:{t:"Light drizzle",e:"üå¶Ô∏è",bg:"rainy"}, 53:{t:"Moderate drizzle",e:"üå¶Ô∏è",bg:"rainy"}, 55:{t:"Dense drizzle",e:"üåßÔ∏è",bg:"rainy"},
      56:{t:"Freezing drizzle: light",e:"üåßÔ∏è",bg:"rainy"}, 57:{t:"Freezing drizzle: dense",e:"üåßÔ∏è",bg:"rainy"},
      61:{t:"Slight rain",e:"üåßÔ∏è",bg:"rainy"}, 63:{t:"Moderate rain",e:"üåßÔ∏è",bg:"rainy"}, 65:{t:"Heavy rain",e:"üåßÔ∏è",bg:"rainy"},
      66:{t:"Freezing rain: light",e:"üåßÔ∏è",bg:"rainy"}, 67:{t:"Freezing rain: heavy",e:"üåßÔ∏è",bg:"rainy"},
      71:{t:"Slight snow",e:"üå®Ô∏è",bg:"cloudy"}, 73:{t:"Moderate snow",e:"‚ùÑÔ∏è",bg:"cloudy"}, 75:{t:"Heavy snow",e:"‚ùÑÔ∏è",bg:"cloudy"}, 77:{t:"Snow grains",e:"üå®Ô∏è",bg:"cloudy"},
      80:{t:"Rain showers: slight",e:"üåßÔ∏è",bg:"rainy"}, 81:{t:"Rain showers: moderate",e:"üåßÔ∏è",bg:"rainy"}, 82:{t:"Rain showers: violent",e:"üåßÔ∏è",bg:"rainy"},
      85:{t:"Snow showers: slight",e:"üå®Ô∏è",bg:"cloudy"}, 86:{t:"Snow showers: heavy",e:"‚ùÑÔ∏è",bg:"cloudy"},
      95:{t:"Thunderstorm",e:"‚õàÔ∏è",bg:"rainy"}, 96:{t:"Thunderstorm with slight hail",e:"‚õàÔ∏è",bg:"rainy"}, 99:{t:"Thunderstorm with heavy hail",e:"‚õàÔ∏è",bg:"rainy"}
    };

    // DOM
    const els = {
      emoji: document.getElementById("emoji"),
      temp: document.getElementById("temp"),
      cond: document.getElementById("cond"),
      humid: document.getElementById("humid"),
      wind: document.getElementById("wind"),
      feels: document.getElementById("feels"),
      ltime: document.getElementById("ltime"),
      greeting: document.getElementById("greeting"),
      status: document.getElementById("status"),
      refresh: document.getElementById("refresh"),
      forecast: document.getElementById("forecast"),
      city: document.getElementById("city"),
      btnSearch: document.getElementById("btn-search"),
      btnMyLoc: document.getElementById("btn-myloc"),
      btnCast: document.getElementById("btn-cast"),
      btnCopy: document.getElementById("btn-copy"),
      btnAddMiniapp: document.getElementById("btn-add-miniapp"),
      userFid: document.getElementById("user-fid"),
      locationModal: document.getElementById("locationModal"),
      modalTitle: document.getElementById("modal-title"),
      modalMessage: document.getElementById("modal-message"),
      retryLocation: document.getElementById("retryLocation"),
      useIP: document.getElementById("useIP")
    };

    // Storage helpers
    const save = (k,v) => localStorage.setItem(k, JSON.stringify(v));
    const load = (k,d=null) => { try { return JSON.parse(localStorage.getItem(k)) ?? d; } catch { return d; } };

    // UI helpers
    function setBackgroundByCode(code, isNight=false){
      const info = WMO[code] || WMO[2];
      document.body.className = isNight ? "bg-night" : `bg-${info.bg}`;
    }
    function formatTimeLocal(dateStr){
      try{ return new Date(dateStr).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }catch{return "--:--";}
    }
    function toast(msg){
      els.status.textContent = msg;
      setTimeout(()=> els.status.textContent = "", 2500);
    }
    function copy(t){ 
      try{ 
        // Use document.execCommand('copy') for better compatibility in iFrames
        const tempTextArea = document.createElement("textarea");
        tempTextArea.value = t;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextArea);
        toast("üìã Copied to clipboard!");
      }catch(e){
        console.error("Copy failed:", e);
        toast("Copy failed");
      } 
    }

    // Show/hide modal
    function showLocationModal(title = "Enable Location Access", message = "To get accurate weather for your area, please allow location access in your browser settings. This uses your device's GPS or nearby cell towers/WiFi for precision.") {
      els.modalTitle.textContent = title;
      els.modalMessage.textContent = message;
      els.locationModal.style.display = "block";
    }
    function hideLocationModal() {
      els.locationModal.style.display = "none";
    }

    // Handle notification open (via URL params)
    function handleNotificationContext() {
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('context') === 'notification') {
        const title = urlParams.get('title') || 'Daily Weather Alert';
        const body = urlParams.get('body') || 'Check your local forecast now.';
        toast(`üîî Opened from notification: ${title} - ${body}`);
        // Optionally, set greeting or update UI based on notification
        els.greeting.textContent = `${body} Thanks for checking in! üå§Ô∏è`;
        console.log('Notification context detected via URL params');
      }
    }

    // Relative "Updated Xm ago"
    let lastUpdatedTs = null;
    function setUpdatedNow(){
      lastUpdatedTs = Date.now();
      els.refresh.textContent = `Updated ‚Ä¢ ${new Date(lastUpdatedTs).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
    }
    setInterval(()=>{
      if (!lastUpdatedTs) return;
      const mins = Math.floor((Date.now() - lastUpdatedTs)/60000);
      if (mins <= 0) return;
      els.refresh.textContent = `Updated ‚Ä¢ ${mins}m ago`;
    }, 60000);

    // Weather fetch
    async function fetchWeather(lat, lon){
      const url = `${OPEN_METEO}?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,wind_speed_10m,weather_code,is_day&hourly=weather_code,temperature_2m&daily=weather_code,temperature_2m_max,temperature_2m_min&forecast_days=5&timezone=auto`;
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok) throw new Error("Weather fetch failed");
      return res.json();
    }
    async function geocodeCity(q){
      const url = `${GEO_CODE}?name=${encodeURIComponent(q)}&count=1&language=en&format=json`;
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok) throw new Error("City lookup failed");
      const data = await res.json();
      if (!data.results || !data.results.length) throw new Error("City not found");
      const r = data.results[0];
      return { name: r.name, latitude: r.latitude, longitude: r.longitude, country:r.country };
    }

    // Render
    function render(data, placeName = "Your location"){
      try{
        const cur = data.current;
        const daily = data.daily;
        const code = cur.weather_code;
        const info = WMO[code] || {t:"Unknown", e:"‚õÖ", bg:"cloudy"};
        const isNight = (typeof cur.is_day === "number") ? (cur.is_day === 0) : false;

        setBackgroundByCode(code, isNight);
        els.emoji.textContent = info.e;
        els.temp.textContent = `${Math.round(cur.temperature_2m)}¬∞C`;
        els.cond.textContent = `${info.t} ‚Ä¢ ${placeName}`;
        els.humid.textContent = `${Math.round(cur.relative_humidity_2m)}%`;
        els.wind.textContent = `${Math.round(cur.wind_speed_10m)} km/h`;
        els.feels.textContent = `${Math.round(cur.apparent_temperature ?? cur.temperature_2m)}¬∞C`;
        els.ltime.textContent = formatTimeLocal(cur.time);

        // Temp-change alert
        const prevTemp = load("lastTemp", null);
        if (prevTemp !== null && Math.abs(prevTemp - cur.temperature_2m) > 3){
          toast(`üå°Ô∏è Temp changed ${Math.round(cur.temperature_2m - prevTemp)}¬∞C since last check`);
        }
        save("lastTemp", cur.temperature_2m);

        // Adaptive greeting
        adaptiveGreeting(code, (placeName || "").split(",")[0]);

        // Forecast
        els.forecast.innerHTML = "";
        if (daily && daily.time && daily.time.length){
          const days = daily.time.slice(0,5);
          days.forEach((d,i)=>{
            const dcode = daily.weather_code[i];
            const max = Math.round(daily.temperature_2m_max[i]);
            const min = Math.round(daily.temperature_2m_min[i]);
            const label = new Date(d).toLocaleDateString([], { weekday:"short" });
            const dinfo = WMO[dcode] || {e:"‚õÖ"};
            const node = document.createElement("div");
            node.className = "fcard";
            node.innerHTML = `
              <div class="fday">${label}</div>
              <div style="font-size:18px;margin:4px 0">${dinfo.e}</div>
              <div class="ftemp">‚Üë${max}¬∞ ‚Üì${min}¬∞</div>
            `;
            els.forecast.appendChild(node);
          });
        }

        save("lastWeather", { data, placeName, ts: Date.now() });
      }catch(err){
        console.error(err);
        els.status.textContent = "Render error";
      }
    }

    async function loadByCoords(lat, lon, label){
      els.status.textContent = "Loading weather‚Ä¶";
      try{
        const data = await fetchWeather(lat, lon);
        render(data, label);
        setUpdatedNow();
        els.status.textContent = "";
      }catch(err){
        console.error(err);
        els.status.textContent = "Offline ‚Äî showing saved weather data ‚òÅÔ∏è";
        const cache = load("lastWeather");
        if (cache){ render(cache.data, cache.placeName || label); }
      }
    }

    // IP-based location fallback
    async function getIPLocation() {
      try {
        const res = await fetch('https://ipapi.co/json/');
        if (!res.ok) throw new Error("IP fetch failed");
        const data = await res.json();
        if (data.error) throw new Error(data.reason);
        if (data.latitude && data.longitude) {
          const label = data.city ? `${data.city}${data.region ? `, ${data.region}` : ''}, ${data.country_name || data.country}`.trim() : "Your approximate location";
          return { lat: parseFloat(data.latitude), lon: parseFloat(data.longitude), label, from:"ip" };
        } else {
          throw new Error("No coords in IP data");
        }
      } catch(err) {
        console.warn("IP lookup failed:", err);
        return { lat: DEFAULT_CITY.latitude, lon: DEFAULT_CITY.longitude, label: DEFAULT_CITY.name, from:"fallback" };
      }
    }

    // Geolocation error messages
    function getGeolocationErrorMessage(code, message) {
      switch (code) {
        case 1:
          return {
            title: "üìç Location Permission Denied",
            message: "You denied location access. Please enable it in your browser settings for accurate local weather."
          };
        case 2:
          return {
            title: "üìç Location Unavailable",
            message: "Unable to determine your location. This could be due to no GPS signal or device issues. Trying approximate location."
          };
        case 3:
          return {
            title: "üìç Location Timeout",
            message: "Location request timed out. Please check your connection or try again. Falling back to approximate location."
          };
        default:
          return {
            title: "üìç Location Error",
            message: `An error occurred: ${message}. Falling back to approximate location.`
          };
      }
    }

    // Improved geolocation with GPS first, then network (cell/WiFi), then IP
    async function getGeoLocation(accuracy = 'high') {
      const options = {
        timeout: 15000,
        maximumAge: 0,
        enableHighAccuracy: accuracy === 'high'
      };
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, (error) => {
          reject(error);
        }, options);
      });
    }

    async function initGeolocation() {
      if (!navigator.geolocation) {
        toast("üìç Geolocation not supported");
        return await getIPLocation();
      }

      try {
        // 1st: GPS (high accuracy)
        const pos = await getGeoLocation('high');
        console.log("‚úÖ GPS location detected:", pos.coords);
        toast("üìç Using GPS location");
        return { lat: pos.coords.latitude, lon: pos.coords.longitude, label: "Your location", from:"gps" };
      } catch(err) {
        let errorInfo = getGeolocationErrorMessage(err.code, err.message);
        console.warn("‚ö†Ô∏è GPS error:", err);
        if (err.code === 1) { // PERMISSION_DENIED
          toast("‚ö†Ô∏è Location permission denied");
          showLocationModal(errorInfo.title, errorInfo.message);
          throw err; // Let caller handle modal
        }

        try {
          // 2nd: Network (cell tower/WiFi, low accuracy)
          const pos = await getGeoLocation('low');
          console.log("‚úÖ Network location (cell/WiFi) detected:", pos.coords);
          toast("üìç Using nearby cell tower/WiFi location");
          return { lat: pos.coords.latitude, lon: pos.coords.longitude, label: "Your approximate location", from:"network" };
        } catch(netErr) {
          let netErrorInfo = getGeolocationErrorMessage(netErr.code, netErr.message);
          console.warn("‚ö†Ô∏è Network location error:", netErr);
          if (netErr.code === 1) { // Also denied
            toast("‚ö†Ô∏è Location permission denied");
            showLocationModal(netErrorInfo.title, netErrorInfo.message);
            throw netErr;
          }
          // 3rd: IP
          return await getIPLocation();
        }
      }
    }

    // Schedules
    let lastGeo = null;
    let refreshTimer = null;
    function scheduleAutoRefresh(lat, lon, label){
      const threeHours = 3 * 60 * 60 * 1000;
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(()=> loadByCoords(lat, lon, label), threeHours);
      document.addEventListener("visibilitychange", ()=>{
        if (!document.hidden){ loadByCoords(lat, lon, label); }
      }, { once:true });
    }

    // Adaptive greeting (time + weather)
    function adaptiveGreeting(code, name){
      const hr = new Date().getHours();
      const base =
        (hr >= 6 && hr < 12) ? "‚òÄÔ∏è Good morning" :
        (hr >= 12 && hr < 18) ? "üå§Ô∏è Good afternoon" :
        "üåô Good evening";
      let tail = " Let's build something new today.";
      if ([0,1].includes(code)) tail = " Bright and clear ‚Äî perfect day to ship!";
      else if ([2,3,45,48].includes(code)) tail = " Cloudy skies ‚Äî cozy coding weather.";
      else if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)) tail = " Rainy vibes ‚Äî great time to code indoors.";
      else if ([71,73,75,77,85,86].includes(code)) tail = " Snowy mood ‚Äî warm beverage and deep focus.";
      else if ([95,96,99].includes(code)) tail = " Stormy out ‚Äî perfect to build something big inside.";
      const msg = `${base}${name?`, ${name}`:""}!${tail}`;
      els.greeting.textContent = msg;
      save("greetMsg", msg);
    }

    // Morning greeting check + optional notifications (now Farcaster-aware; Neynar handles sending)
    async function checkMorningGreeting(farcasterContext = null) {
      const lastMsgDate = load("lastGreetDate", "");
      const today = new Date().toDateString();
      if (lastMsgDate !== today) {
        const greetMsg = load("greetMsg", "Good morning!");
        toast(greetMsg);
        if ("Notification" in window && Notification.permission === "granted") {
          try { new Notification("üå§Ô∏è Daily Weather", { body: greetMsg }); } catch {}
        }
        // Neynar handles notifications server-side; no queue needed here
        console.log("‚úÖ Morning greeting shown; notifications via Neynar");
        save("lastGreetDate", today);
      }
    }
    if ("Notification" in window && Notification.permission === "default") {
      try { Notification.requestPermission().catch(()=>{}); } catch {}
    }
    setInterval(()=>{
      const hr = new Date().getHours();
      if (hr >= 6 && hr < 9) checkMorningGreeting();
    }, 60 * 60 * 1000);

    // Generate weather text for sharing
    function getWeatherText(){
      const emoji = els.emoji.textContent;
      const temp = els.temp.textContent;
      const cond = els.cond.textContent;
      const humid = els.humid.textContent;
      const wind = els.wind.textContent;
      return `${emoji} Weather Update\n\n${temp} ${cond}\nüíß ${humid} humidity ‚Ä¢ üçÉ ${wind} wind\n\nvia CastWeather MiniApp üå§Ô∏è`;
    }

    // Cast weather using Farcaster SDK
    async function castWeather(){
      try {
        els.btnCast.disabled = true;
        els.btnCast.textContent = "Casting...";
        
        const result = await sdk.actions.composeCast({
          text: getWeatherText(),
          embeds: ["https://weather-base-app.vercel.app/"]
        });

        if (result?.cast) {
          toast(`‚úÖ Cast posted! Hash: ${result.cast.hash.slice(0,10)}...`);
          console.log("Cast hash:", result.cast.hash);
          if (result.cast.channelKey) {
            console.log("Posted to channel:", result.cast.channelKey);
          }
        } else {
          toast("Cast cancelled");
        }
      } catch(err) {
        console.error("Cast error:", err);
        toast("Cast failed - try copy instead");
      } finally {
        els.btnCast.disabled = false;
        els.btnCast.textContent = "üü£ CastWeather";
      }
    }

    // Copy to clipboard
    function copyWeather(){
      copy(getWeatherText());
    }

    // Add MiniApp using Farcaster SDK
    async function addMiniApp(){
      try {
        els.btnAddMiniapp.disabled = true;
        els.btnAddMiniapp.textContent = "Adding...";
        
        const result = await sdk.actions.addMiniApp();
        if (result.added) {
          toast("‚úÖ MiniApp added! Enable notifications in app settings for daily alerts.");
          console.log('App added successfully');
        } else {
          console.error('Add failed:', result.reason);
          toast("Add MiniApp failed - check console");
        }
      } catch(err) {
        console.error("Add MiniApp error:", err);
        toast("Add MiniApp failed");
      } finally {
        els.btnAddMiniapp.disabled = false;
        els.btnAddMiniapp.textContent = "‚ûï Add MiniApp";
      }
    }

    // Initialize Farcaster context
    let farcasterUser = null;
    let farcasterContext = null;
    async function initFarcasterContext(){
      try {
        // Try to get authenticated user via Quick Auth
        farcasterContext = await sdk.context;
        if (farcasterContext?.user?.fid) {
          farcasterUser = farcasterContext.user;
          els.userFid.textContent = `FID: ${farcasterUser.fid}`;
          els.userFid.style.display = "inline-flex";
          console.log("Farcaster user:", farcasterUser);
        }
      } catch(err) {
        console.log("No Farcaster context (running outside miniapp):", err);
      }
    }

    // Events
    els.btnSearch.addEventListener("click", async ()=>{
      const q = els.city.value.trim();
      if (!q) return;
      els.status.textContent = "Searching city‚Ä¶";
      try{
        const loc = await geocodeCity(q);
        els.city.blur();
        const label = `${loc.name}, ${loc.country || ""}`.trim();
        await loadByCoords(loc.latitude, loc.longitude, label);
        scheduleAutoRefresh(loc.latitude, loc.longitude, label);
        save("lastCity", loc);
      }catch(err){
        console.error(err);
        els.status.textContent = "City not found";
      }
    });
    els.city.addEventListener("keydown", (e)=>{ if (e.key === "Enter") els.btnSearch.click(); });
    els.btnCast.addEventListener("click", castWeather);
    els.btnCopy.addEventListener("click", copyWeather);
    els.btnAddMiniapp.addEventListener("click", addMiniApp);

    // üìç button logic
    els.btnMyLoc.addEventListener("click", async ()=>{
      try {
        els.status.textContent = "üìç Detecting your location‚Ä¶";
        const { lat, lon, label, from } = await initGeolocation();
        lastGeo = { lat, lon, label };
        await loadByCoords(lat, lon, label);
        scheduleAutoRefresh(lat, lon, label);
        els.status.textContent = from === "gps" 
          ? "‚úÖ GPS location loaded"
          : from === "network" 
          ? "üìç Network (cell/WiFi) location loaded"
          : from === "ip" 
          ? "üìç IP-based location loaded"
          : "‚ö†Ô∏è Using default city";
      } catch(err) {
        // Modal is shown in initGeolocation on denial
        console.warn("Location denied, modal shown");
      }
    });

    // Modal events
    els.retryLocation.addEventListener("click", async () => {
      hideLocationModal();
      els.status.textContent = "üìç Retrying GPS location‚Ä¶";
      try {
        const { lat, lon, label, from } = await initGeolocation();
        lastGeo = { lat, lon, label };
        await loadByCoords(lat, lon, label);
        scheduleAutoRefresh(lat, lon, label);
        els.status.textContent = from === "gps" 
          ? "‚úÖ GPS location loaded"
          : from === "network" 
          ? "üìç Network location loaded"
          : "‚ö†Ô∏è Still unable to get location";
      } catch(retryErr) {
        // If retry also denied, keep modal or fallback
        if (retryErr.code === 1) {
          const errorInfo = getGeolocationErrorMessage(retryErr.code, retryErr.message);
          showLocationModal(errorInfo.title, errorInfo.message);
        } else {
          // Fallback to IP for other errors
          els.status.textContent = "üìç Falling back to IP location‚Ä¶";
          const ipLoc = await getIPLocation();
          lastGeo = { lat: ipLoc.lat, lon: ipLoc.lon, label: ipLoc.label };
          await loadByCoords(ipLoc.lat, ipLoc.lon, ipLoc.label);
          scheduleAutoRefresh(ipLoc.lat, ipLoc.lon, ipLoc.label);
          els.status.textContent = "üìç IP-based location loaded";
        }
      }
    });

    els.useIP.addEventListener("click", async () => {
      hideLocationModal();
      els.status.textContent = "üìç Using approximate IP location‚Ä¶";
      const ipLoc = await getIPLocation();
      lastGeo = { lat: ipLoc.lat, lon: ipLoc.lon, label: ipLoc.label };
      await loadByCoords(ipLoc.lat, ipLoc.lon, ipLoc.label);
      scheduleAutoRefresh(ipLoc.lat, ipLoc.lon, ipLoc.label);
      els.status.textContent = ipLoc.from === "ip" ? "üìç IP-based location loaded" : "‚ö†Ô∏è Using default city";
    });

    // Boot sequence
    (async function boot(){
      console.log("üß≠ Boot: starting geolocation detection...");

      // Check for notification context first
      handleNotificationContext();

      // Show cached data immediately
      const cached = load("lastWeather");
      if (cached) { render(cached.data, cached.placeName); }

      // Initialize Farcaster context
      await initFarcasterContext();

      // Load initial weather
      try {
        const { lat, lon, label, from } = await initGeolocation();
        lastGeo = { lat, lon, label };
        await loadByCoords(lat, lon, label);
        scheduleAutoRefresh(lat, lon, label);
        
        // Update status to reflect boot result
        els.status.textContent = from === "gps" 
          ? "‚úÖ GPS location loaded"
          : from === "network" 
          ? "üìç Network (cell/WiFi) location loaded"
          : from === "ip" 
          ? "üìç IP-based location loaded"
          : "‚ö†Ô∏è Using default city (location unavailable)";
      } catch(err) {
        // On denial during boot, show modal
        if (err.code === 1) {
          const errorInfo = getGeolocationErrorMessage(err.code, err.message);
          els.status.textContent = "‚ö†Ô∏è Location permission needed for accurate weather";
          showLocationModal(errorInfo.title, errorInfo.message);
          // Proceed with IP fallback after short delay
          setTimeout(async () => {
            const ipLoc = await getIPLocation();
            lastGeo = { lat: ipLoc.lat, lon: ipLoc.lon, label: ipLoc.label };
            await loadByCoords(ipLoc.lat, ipLoc.lon, ipLoc.label);
            scheduleAutoRefresh(ipLoc.lat, ipLoc.lon, ipLoc.label);
            els.status.textContent = ipLoc.from === "ip" ? "üìç IP-based location loaded" : "‚ö†Ô∏è Using default city";
          }, 1000);
        } else {
          // For other errors, fallback to IP
          const errorInfo = getGeolocationErrorMessage(err.code || 0, err.message || "Unknown error");
          toast(errorInfo.message);
          const ipLoc = await getIPLocation();
          lastGeo = { lat: ipLoc.lat, lon: ipLoc.lon, label: ipLoc.label };
          await loadByCoords(ipLoc.lat, ipLoc.lon, ipLoc.label);
          scheduleAutoRefresh(ipLoc.lat, ipLoc.lon, ipLoc.label);
          els.status.textContent = ipLoc.from === "ip" ? "üìç IP-based location loaded" : "‚ö†Ô∏è Using default city";
        }
      }

      const lastCity = load("lastCity");
      if (lastCity) els.city.placeholder = `Try: ${lastCity.name}`;

      const hr = new Date().getHours();
      if (hr >= 6 && hr < 9) checkMorningGreeting(farcasterContext);

      // Signal to Farcaster that app is ready
      try {
        await sdk.actions.ready();
        console.log("‚úÖ Farcaster SDK ready");
      } catch(err) {
        console.log("Not in Farcaster context or SDK error:", err);
      }
    })();
  </script>
</body>
</html>
